package plugins

import org.apache.commons.io.output.NullOutputStream
import org.gradle.api.DefaultTask
import org.gradle.api.Plugin
import org.gradle.api.Project
import org.gradle.api.file.RegularFile
import org.gradle.api.tasks.*
import org.gradle.kotlin.dsl.*
import org.gradle.process.ExecOperations
import plugins.IslePlugin.Companion.isDockerProject
import javax.inject.Inject
import plugins.SharedPropertiesPlugin.Companion.execCaptureOutput
import plugins.SharedPropertiesPlugin.Companion.isleRepository
import plugins.SharedPropertiesPlugin.Companion.isleTag
import tasks.DockerPull

// Generate reports via Syft and Grype.
@Suppress("unused")
class ReportsPlugin : Plugin<Project> {

    companion object {
        // Configuration for grype.
        val Project.grypeConfig: RegularFile?
            get() = (properties.getOrDefault("isle.grype.config", "") as String).let { path: String ->
                if (path.isNotBlank()) {
                    project.layout.projectDirectory.file(path).let { file ->
                        if (file.asFile.exists())
                            file
                        else
                            null
                    }
                }
                null
            }

        // Only reports issues that have fixes.
        val Project.grypeOnlyFixed: Boolean
            get() = (properties.getOrDefault("isle.grype.only-fixed", "false") as String).toBoolean()

        // Triggers build to fail if security vulnerability is discovered.
        // If unspecified the build will continue regardless.
        // Possible values: negligible, low, medium, high, critical.
        // Only reports issues that have fixes.
        val Project.grypeFailOnSeverity: String
            get() = properties.getOrDefault("isle.grype.fail-on-severity", "") as String

        // The format of reports generated by grype.
        // Possible values: table, cyclonedx, json, template.
        val Project.grypeFormat: String
            get() = properties.getOrDefault("isle.grype.format", "table") as String
    }

    // Updates Grype Database.
    @CacheableTask
    abstract class UpdateGrypeDB : DefaultTask() {
        @get:Inject
        abstract val execOperations: ExecOperations
        @Input
        val image = project.objects.property<String>()

        @OutputDirectory
        val database = project.objects.directoryProperty().convention(project.layout.buildDirectory.dir("grype"))

        @Internal
        val uid = project.objects.property<Int>()

        @Internal
        val gid = project.objects.property<Int>()

        private val baseArguments: List<String>
            get() = listOf(
                "docker",
                "run",
                "--rm",
                "-u", "${uid.get()}:${gid.get()}",
                "-e", "XDG_CACHE_HOME=/cache",
                "-v", "${database.get().asFile.absolutePath}:/cache",
                "-v", "/tmp:/tmp",
                image.get(),
            )

        private fun upToDate() = execOperations.exec {
            commandLine(
                baseArguments + listOf(
                    "db",
                    "status"
                )
            )
            standardOutput = NullOutputStream()
            errorOutput = NullOutputStream()
            isIgnoreExitValue = true
        }.exitValue == 0

        init {
            outputs.upToDateWhen {
                // If the database is missing the task will re-run or be restored from cache.
                // If the database is present check to make sure it is up-to-date, if not run again.
                database.get().asFile.exists() && upToDate()
            }
            uid.set(project.execCaptureOutput(listOf("id", "-u"), "Failed to get UID").toInt())
            gid.set(project.execCaptureOutput(listOf("id", "-g"), "Failed to get GID").toInt())
        }

        @TaskAction
        fun pull() {
            execOperations.exec {
                commandLine(
                    baseArguments + listOf(
                        "db",
                        "update"
                    )
                )
            }
        }
    }


    // Wrapper around a call to `syft`, please refer to the documentation for more information:
    // https://github.com/anchore/syft
    @CacheableTask
    abstract class Syft : DefaultTask() {
        @get:Inject
        abstract val execOperations: ExecOperations

        // anchore/syft image.
        @Input
        val syft = project.objects.property<String>()

        // The image to process (assumed to exist locally).
        @Input
        val image = project.objects.property<String>()

        // A json file representing the generated Software Bill of Materials.
        @OutputFile
        val sbom = project.objects.fileProperty().convention(project.layout.buildDirectory.file("sbom.json"))

        @TaskAction
        fun exec() {
            sbom.get().asFile.outputStream().use { output ->
                execOperations.exec {
                    standardOutput = output
                    commandLine = listOf(
                        "docker", "container", "run", "--rm",
                        "-v", "/var/run/docker.sock:/var/run/docker.sock",
                        syft.get(),
                        "-o", "json",
                        image.get()
                    )
                }
            }
        }
    }

    // Wrapper around a call to `syft`, please refer to the documentation for more information:
    // https://github.com/anchore/syft
    @CacheableTask
    abstract class Grype : DefaultTask() {
        @get:Inject
        abstract val execOperations: ExecOperations
        // anchore/grype image.
        @Input
        val grype = project.objects.property<String>()

        // anchore/grype image.
        @InputDirectory
        @PathSensitive(PathSensitivity.RELATIVE)
        val database = project.objects.directoryProperty()

        // A json file representing the generated Software Bill of Materials.
        @InputFile
        @PathSensitive(PathSensitivity.RELATIVE)
        val sbom = project.objects.fileProperty()

        @Input
        val format = project.objects.property<String>().convention("table")

        @Input
        @Optional
        val failOn = project.objects.property<String>()

        @InputFile
        @Optional
        @PathSensitive(PathSensitivity.RELATIVE)
        val config = project.objects.fileProperty()

        @Input
        val onlyFixed = project.objects.property<Boolean>().convention(false)

        @OutputFile
        val report = project.objects.fileProperty().convention(format.flatMap {
            val dir = project.layout.buildDirectory
            val name = "${project.name}-grype"
            when (it) {
                "json" -> dir.file("${name}.json")
                "table" -> dir.file("${name}.md")
                "cyclonedx" -> dir.file("${name}.xml")
                else -> dir.file("${name}.txt")
            }
        })

        @TaskAction
        fun exec() {
            sbom.get().asFile.inputStream().use { input ->
                report.get().asFile.outputStream().use { output ->
                    // Arguments to docker.
                    val command = mutableListOf(
                        "docker", "container", "run", "--rm", "-i",
                        "-e", "XDG_CACHE_HOME=/cache",
                        "-e", "GRYPE_DB_AUTO_UPDATE=false",
                        "-v", "${database.get().asFile.absolutePath}:/cache",
                    )
                    if (config.isPresent) {
                        command.addAll(listOf("-v", "${config.get().asFile.absolutePath}:/grype.yaml"))
                    }
                    // Docker image
                    command.add(grype.get())
                    if (config.isPresent) {
                        command.addAll(listOf("--config", "/grype.yaml"))
                    }
                    // Arguments to grype.
                    if (failOn.get().isNotBlank()) {
                        command.addAll(listOf("--fail-on", failOn.get()))
                    }
                    if (onlyFixed.get()) {
                        command.add("--only-fixed")
                    }
                    command.addAll(listOf("-o", format.get()))
                    execOperations.exec {
                        standardInput = input
                        standardOutput = output
                        commandLine = command
                    }
                }
            }
        }
    }

    override fun apply(pluginProject: Project): Unit = pluginProject.run {
        apply<SharedPropertiesPlugin>()

        val pullSyft by tasks.registering(DockerPull::class) {
            group = "Isle Reports"
            description = "Pull anchore/syft docker image"
            image.set("anchore/syft")
        }

        val pullGrype by tasks.registering(DockerPull::class) {
            group = "Isle Reports"
            description = "Pull anchore/grype docker image"
            image.set("anchore/grype")
        }

        val updateGrypeDB by tasks.registering(UpdateGrypeDB::class) {
            group = "Isle Reports"
            description = "Update the Grype Database"
            image.set(pullGrype.map { it.digestFile.get().asFile.readText().trim() })
        }

        allprojects {
            // Auto-apply plugins to relevant projects.
            if (isDockerProject) {
                val syft by tasks.registering(Syft::class) {
                    group = "Isle Reports"
                    description = "Generate a software bill of material with Syft"
                    syft.set(pullSyft.map { it.digest })
                    image.set((properties.getOrDefault("isle.${project.name}.digest", "") as String).ifEmpty { "${project.isleRepository}/${project.name}:${project.isleTag}" })
                }

                tasks.register<Grype>("grype") {
                    group = "Isle Reports"
                    description = "Process the software bill of material with Grype"
                    grype.set(pullGrype.map { it.digest })
                    database.set(updateGrypeDB.flatMap { it.database })
                    config.set(grypeConfig)
                    failOn.set(grypeFailOnSeverity)
                    format.set(grypeFormat)
                    onlyFixed.set(grypeOnlyFixed)
                    sbom.set(syft.flatMap { it.sbom })
                    dependsOn(":updateGrypeDB")
                }
            }
        }
    }
}
